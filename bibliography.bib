@article{DirectedIncrementalSymExe,
author = {Yang, Guowei and Person, Suzette and Rungta, Neha and Khurshid, Sarfraz},
title = {Directed Incremental Symbolic Execution},
institution = {NASA, University of Texas},
url = {https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20110023245.pdf},
year = {2014}}

@InProceedings{chopper:icse18,
author = {David Trabish and Andrea Mattavelli and Noam Rinetzky and Cristian Cadar},
title = {Chopped Symbolic Execution},
booktitle = {International Conference on Software Engineering (ICSE 2018)},
year = {2018},
month = {5},
location = {Gothenburg, Sweden},
}

% Microsoft
@inproceedings{bouncer-securing-software-by-blocking-bad-input,
author = {Costa, Manuel and Castro, Miguel and Zhou, Lidong and Zhang, Lintao and Peinado, Marcus},
title = {Bouncer: Securing Software by Blocking Bad Input},
booktitle = {},
year = {2007},
month = {October},
abstract = {Attackers exploit software vulnerabilities to control or crash programs. Bouncer uses existing software instrumentation techniques to detect attacks and it generates filters automatically to block exploits of the target vulnerabilities. The filters are deployed automatically by instrumenting system calls to drop exploit messages. These filters introduce low overhead and they allow programs to keep running correctly under attack. Previous work computes filters using symbolic execution along the path taken by a sample exploit, but attackers can bypass these filters by generating exploits that follow a different execution path. Bouncer introduces three techniques to generalize filters so that they are harder to bypass: a new form of program slicing that uses a combination of static and dynamic analysis to remove unnecessary conditions from the filter; symbolic summaries for common library functions that characterize their behavior succinctly as a set of conditions on the input; and generation of alternative exploits guided by symbolic execution. Bouncer filters have low overhead, they do not have false positives by design, and our results show that Bouncer can generate filters that block all exploits of some real-world vulnerabilities.},
publisher = {Association for Computing Machinery, Inc.},
url = {https://www.microsoft.com/en-us/research/publication/bouncer-securing-software-by-blocking-bad-input/},
address = {Stevenson, Washington, USA},
pages = {117-130},
journal = {},
volume = {},
chapter = {},
isbn = {978-1-59593-591-5},
}

@inproceedings{Visser:2004:TIG:1007512.1007526,
 author = {Visser, Willem and P\v{a}s\v{a}reanu, Corina S. and Khurshid, Sarfraz},
 title = {Test Input Generation with Java PathFinder},
 booktitle = {Proceedings of the 2004 ACM SIGSOFT International Symposium on Software Testing and Analysis},
 series = {ISSTA '04},
 year = {2004},
 isbn = {1-58113-820-2},
 location = {Boston, Massachusetts, USA},
 pages = {97--107},
 numpages = {11},
 url = {http://users.ece.utexas.edu/~khurshid/papers/JPF-issta04.pdf},
 doi = {10.1145/1007512.1007526},
 acmid = {1007526},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {coverage, model checking, red-black trees, symbolic execution, testing object-oriented programs},
}

% Symbolic execution in networks.
@inproceedings {220590,
author = {Mathy Vanhoef and Frank Piessens},
title = {Symbolic Execution of Security Protocol Implementations: Handling Cryptographic Primitives},
booktitle = {12th {USENIX} Workshop on Offensive Technologies ({WOOT} 18)},
year = {2018},
address = {Baltimore, MD},
url = {https://papers.mathyvanhoef.com/woot2018.pdf},
publisher = {{USENIX} Association}
}

% Symbolic execution to detect exploits in hardware
@article{Hardware,
author = {Zhang, Rui and Sturton, Cynthia},
year = {2018},
month = {06},
url = {https://cs.unc.edu/~csturton/papers/FMS2018.pdf},
pages = {1-9},
title = {A recursive strategy for symbolic execution to find exploits in hardware designs}
}

@INPROCEEDINGS{5635129,
author={M. Papadakis and N. Malevris},
booktitle={2010 IEEE 21st International Symposium on Software Reliability Engineering},
title={Automatic Mutation Test Case Generation via Dynamic Symbolic Execution},
year={2010},
volume={},
number={},
url={http://pages.cs.aueb.gr/~mpapad/papers/ISSRE2010.pdf},
pages={121-130},
keywords={program testing;automatic mutation test case generation;dynamic symbolic execution;software testing activity;structural criteria hierarchy;branch testing;program transformation;test generation process;mutation based test cases;benchmark programs;Flow graphs;Space exploration;Software testing;Production;Process control;Buildings;automated test case generation;dynamic symbolic execution;mutation testing;mutant schemata},
doi={10.1109/ISSRE.2010.38},
ISSN={1071-9458},
month={Nov}
}

@article{threedecadeslater,
author = {Cadar, Cristian and Sen, Koushik},
year = {2013},
month = {02},
pages = {82-90},
title = {Symbolic execution for software testing: Three decades later},
volume = {56},
url = {https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf},
booktitle = {Communications of the ACM}
}

% Quite old but seems to be amongst the first papers on symbolic testing
@article{newapproach,
author = {King, J.C.},
year = {1975},
month = {06},
pages = {228-233},
url = {https://yurichev.com/mirrors/king76symbolicexecution.pdf},
title = {A new approach to program testing},
volume = {10}
}

% A french one, seems interesting to see something from another country than USA/China
@article{frenchapproach,
author = {Rusu, Vlad and du Bousquet, Lydie and Jeron, Thierry},
year = {2000},
month = {09},
url = {https://www.researchgate.net/publication/2453906_An_Approach_to_Symbolic_Test_Generation},
title = {An Approach to Symbolic Test Generation},
booktitle = {Lecture Notes in Computer Science}
}



%% LOAN %%

% Maybe use it as a conclusion as it shows current progress of a framework using existing symolic executions algorithm (current developed tool)
@article{LUCANU2017125,
title = "A generic framework for symbolic execution: A coinductive approach",
journal = "Journal of Symbolic Computation",
volume = "80",
pages = "125 - 163",
year = "2017",
note = "SI: Program Verification",
issn = "0747-7171",
doi = "https://doi.org/10.1016/j.jsc.2016.07.012",
url = "http://www.sciencedirect.com/science/article/pii/S0747717116300499",
pdfUrl = "https://ac.els-cdn.com/S0747717116300499/1-s2.0-S0747717116300499-main.pdf?_tid=087ddba8-6c4a-44cf-959e-2328f22c23d0&acdnat=1538387057_6f97f297433741ef2fc4ce19b4ec5203",
author = "Dorel Lucanu and Vlad Rusu and Andrei Arusoaie",
keywords = "Symbolic execution, Programming language, Formal operational semantics, Reachability logic, Circular coinduction, Program verification"
}

% Propose two optimization techniques to direct the successive runs of the symbolic execution technique 
@incollection{KHALIL2018145,
title = "Chapter Four - Optimizing the Symbolic Execution of Evolving Rhapsody Statecharts",
editor = "Atif M. Memon",
series = "Advances in Computers",
publisher = "Elsevier",
volume = "108",
pages = "145 - 281",
year = "2018",
issn = "0065-2458",
doi = "https://doi.org/10.1016/bs.adcom.2017.09.003",
url = "http://www.sciencedirect.com/science/article/pii/S0065245817300487",
author = "Amal Khalil and Juergen Dingel",
keywords = "Model-driven engineering, Symbolic execution, Incremental verification, State-based behavioral models, State machines, Memoization, Dependency analysis, Model-based analysis",
abstract = "Model-driven engineering (MDE) is an iterative and incremental software development process. Supporting the analysis and the verification of software systems developed following the MDE paradigm requires to adopt incrementality when carrying out these crucial tasks in a more optimized way. Communicating state machines are one of the various formalisms used in MDE tools to model and describe the behavior of distributed, concurrent, and real-time reactive systems (e.g., automotive and avionics systems). Modeling the overall behavior of such systems is carried out in a modular way and on different levels of abstraction (i.e., it starts with modeling the behavior of the individual objects in the system first then modeling the interaction between these objects). Similarly, analyzing and verifying the correctness of the developed models to ensure their quality and their integrity is performed on two main levels. The intralevel is used to analyze the correctness of the individual models in isolation of the others, while the interlevel is used to analyze the overall interoperability of those that are communicating with each other. One way to facilitate the analysis of the overall behavior of a system of communicating state machines is to build the global state space (also known as the global reachability tree) of the system. This process is very expensive and in some cases it may suffer from the state explosion problem. Symbolic execution is a technique that can be used to construct an abstract and a bounded version of the system global state space that is known as a symbolic execution tree (SET), yet the size of the generated trees can be very large especially with big and complex systems that are composed of multiple objects. As the system evolves, one way to avoid regenerating the entire SET and repeating any SET-based analyses that have been already conducted is to utilize the previous SET and its analysis results in optimizing the process of generating the SET of the system after the change. In this chapter, we propose two optimization techniques to direct the successive runs of the symbolic execution technique toward the impacted parts of an evolving state machine model using memoization (MSE) and dependency analysis (DSE), respectively. The evaluation results of both techniques showed significant reduction in some cases compared with the standard symbolic execution technique."
}
