@inproceedings{klee,
 author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
 title = {KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs},
 booktitle = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
 series = {OSDI'08},
 year = {2008},
 location = {San Diego, California},
 pages = {209--224},
 numpages = {16},
 url = {http://dl.acm.org/citation.cfm?id=1855741.1855756},
 acmid = {1855756},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@InProceedings{exe,
author="Cadar, Cristian
and Engler, Dawson",
editor="Godefroid, Patrice",
title="Execution Generated Test Cases: How to Make Systems Code Crash Itself",
booktitle="Model Checking Software",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="2--23",
abstract="This paper presents a technique that uses code to automatically generate its own test cases at run time by using a combination of symbolic and concrete (i.e regular) execution The input values to a program (or software component) provide the standard interface of any testing framework with the program it is testing and generating input values that will explore all the ``interesting'' behavior in the tested program remains an important open problem in software testing research. Our approach works by turning the problem on its head: we lazily generate from within the program itself the input values to the program (and values derived from input values) as needed. We applied the technique to real code and found numerous corner case errors ranging from simple memory overflows and infinite loops to subtle issues in the interpretation of language standards.",
isbn="978-3-540-31899-6"
}

@unknown{memorytablemodel,
author = {Ziying, Dai and Mao, Xiaoguang and Xiaodong, Ma and Rui, Wang},
year = {2010},
month = {01},
pages = {20 - 24},
title = {A Memory Model for Symbolic Execution},
volume = {1},
booktitle = {IFCSTA 2009 Proceedings - 2009 International Forum on Computer Science-Technology and Applications}
}

@inproceedings{memorymodelpointers,
 author = {Coppa, Emilio and D'Elia, Daniele Cono and Demetrescu, Camil},
 title = {Rethinking Pointer Reasoning in Symbolic Execution},
 booktitle = {Proceedings of the 32Nd IEEE/ACM International Conference on Automated Software Engineering},
 series = {ASE 2017},
 year = {2017},
 isbn = {978-1-5386-2684-9},
 location = {Urbana-Champaign, IL, USA},
 pages = {613--618},
 numpages = {6},
 url = {http://dl.acm.org/citation.cfm?id=3155562.3155638},
 acmid = {3155638},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {cybersecurity, fully symbolic memory, program analysis, symbolic execution},
}

@article{neurosymbolicexecution,
author = {{Shen}, S. and {Ramesh}, S. and {Shinde}, S. and {Roychoudhury}, A. and {Saxena}, P.},
title = "{Neuro-Symbolic Execution: The Feasibility of an Inductive Approach to Symbolic Execution}",
journal = {ArXiv e-prints},
archivePrefix = "arXiv",
eprint = {1807.00575},
primaryClass = "cs.PL",
keywords = {Computer Science - Programming Languages},
year = 2018,
month = jul,
adsurl = {http://adsabs.harvard.edu/abs/2018arXiv180700575S},
adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@inproceedings{cuteforc,
 author = {Sen, Koushik and Marinov, Darko and Agha, Gul},
 title = {CUTE: A Concolic Unit Testing Engine for C},
 booktitle = {Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {ESEC/FSE-13},
 year = {2005},
 isbn = {1-59593-014-0},
 location = {Lisbon, Portugal},
 pages = {263--272},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1081706.1081750},
 doi = {10.1145/1081706.1081750},
 acmid = {1081750},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {concolic testing, data structure testing, explicit path model-checking, random testing, testing C programs, unit testing},
}

@inproceedings{Cadar:2011:SES:1985793.1985995,
 author = {Cadar, Cristian and Godefroid, Patrice and Khurshid, Sarfraz and P\u{a}s\u{a}reanu, Corina S. and Sen, Koushik and Tillmann, Nikolai and Visser, Willem},
 title = {Symbolic Execution for Software Testing in Practice: Preliminary Assessment},
 booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
 series = {ICSE '11},
 year = {2011},
 isbn = {978-1-4503-0445-0},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {1066--1071},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/1985793.1985995},
 doi = {10.1145/1985793.1985995},
 acmid = {1985995},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dynamic test generation, generalized symbolic execution},
}

@article{DirectedIncrementalSymExe,
author = {Yang, Guowei and Person, Suzette and Rungta, Neha and Khurshid, Sarfraz},
title = {Directed Incremental Symbolic Execution},
institution = {NASA, University of Texas},
url = {https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20110023245.pdf},
year = {2014}}

@InProceedings{chopper:icse18,
author = {David Trabish and Andrea Mattavelli and Noam Rinetzky and Cristian Cadar},
title = {Chopped Symbolic Execution},
booktitle = {International Conference on Software Engineering (ICSE 2018)},
year = {2018},
month = {5},
location = {Gothenburg, Sweden},
}

% Microsoft
@inproceedings{bouncer-securing-software-by-blocking-bad-input,
author = {Costa, Manuel and Castro, Miguel and Zhou, Lidong and Zhang, Lintao and Peinado, Marcus},
title = {Bouncer: Securing Software by Blocking Bad Input},
booktitle = {},
year = {2007},
month = {October},
abstract = {Attackers exploit software vulnerabilities to control or crash programs. Bouncer uses existing software instrumentation techniques to detect attacks and it generates filters automatically to block exploits of the target vulnerabilities. The filters are deployed automatically by instrumenting system calls to drop exploit messages. These filters introduce low overhead and they allow programs to keep running correctly under attack. Previous work computes filters using symbolic execution along the path taken by a sample exploit, but attackers can bypass these filters by generating exploits that follow a different execution path. Bouncer introduces three techniques to generalize filters so that they are harder to bypass: a new form of program slicing that uses a combination of static and dynamic analysis to remove unnecessary conditions from the filter; symbolic summaries for common library functions that characterize their behavior succinctly as a set of conditions on the input; and generation of alternative exploits guided by symbolic execution. Bouncer filters have low overhead, they do not have false positives by design, and our results show that Bouncer can generate filters that block all exploits of some real-world vulnerabilities.},
publisher = {Association for Computing Machinery, Inc.},
url = {https://www.microsoft.com/en-us/research/publication/bouncer-securing-software-by-blocking-bad-input/},
address = {Stevenson, Washington, USA},
pages = {117-130},
journal = {},
volume = {},
chapter = {},
isbn = {978-1-59593-591-5},
}

@inproceedings{visserWillemCorina,
 author = {Visser, Willem and P\v{a}s\v{a}reanu, Corina S. and Khurshid, Sarfraz},
 title = {Test Input Generation with Java PathFinder},
 booktitle = {Proceedings of the 2004 ACM SIGSOFT International Symposium on Software Testing and Analysis},
 series = {ISSTA '04},
 year = {2004},
 isbn = {1-58113-820-2},
 location = {Boston, Massachusetts, USA},
 pages = {97--107},
 numpages = {11},
 url = {http://users.ece.utexas.edu/~khurshid/papers/JPF-issta04.pdf},
 doi = {10.1145/1007512.1007526},
 acmid = {1007526},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {coverage, model checking, red-black trees, symbolic execution, testing object-oriented programs},
}

% Symbolic execution in networks.
@inproceedings {220590,
author = {Mathy Vanhoef and Frank Piessens},
title = {Symbolic Execution of Security Protocol Implementations: Handling Cryptographic Primitives},
booktitle = {12th {USENIX} Workshop on Offensive Technologies ({WOOT} 18)},
year = {2018},
address = {Baltimore, MD},
url = {https://papers.mathyvanhoef.com/woot2018.pdf},
publisher = {{USENIX} Association}
}

% Symbolic execution to detect exploits in hardware
@article{Hardware,
author = {Zhang, Rui and Sturton, Cynthia},
year = {2018},
month = {06},
url = {https://cs.unc.edu/~csturton/papers/FMS2018.pdf},
pages = {1-9},
title = {A recursive strategy for symbolic execution to find exploits in hardware designs}
}

@INPROCEEDINGS{5635129,
author={M. Papadakis and N. Malevris},
booktitle={2010 IEEE 21st International Symposium on Software Reliability Engineering},
title={Automatic Mutation Test Case Generation via Dynamic Symbolic Execution},
year={2010},
volume={},
number={},
url={http://pages.cs.aueb.gr/~mpapad/papers/ISSRE2010.pdf},
pages={121-130},
keywords={program testing;automatic mutation test case generation;dynamic symbolic execution;software testing activity;structural criteria hierarchy;branch testing;program transformation;test generation process;mutation based test cases;benchmark programs;Flow graphs;Space exploration;Software testing;Production;Process control;Buildings;automated test case generation;dynamic symbolic execution;mutation testing;mutant schemata},
doi={10.1109/ISSRE.2010.38},
ISSN={1071-9458},
month={Nov}
}

@article{threedecadeslater,
author = {Cadar, Cristian and Sen, Koushik},
year = {2013},
month = {02},
pages = {82-90},
title = {Symbolic execution for software testing: Three decades later},
volume = {56},
url = {https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf},
booktitle = {Communications of the ACM}
}

% Quite old but seems to be amongst the first papers on symbolic testing
@article{newapproach,
author = {King, J.C.},
year = {1975},
month = {06},
pages = {228-233},
url = {https://yurichev.com/mirrors/king76symbolicexecution.pdf},
title = {A new approach to program testing},
volume = {10}
}

% A french one, seems interesting to see something from another country than USA/China
@article{frenchapproach,
author = {Rusu, Vlad and du Bousquet, Lydie and Jeron, Thierry},
year = {2000},
month = {09},
url = {https://www.researchgate.net/publication/2453906_An_Approach_to_Symbolic_Test_Generation},
title = {An Approach to Symbolic Test Generation},
booktitle = {Lecture Notes in Computer Science}
}



%% LOAN %%

% Maybe use it as a conclusion as it shows current progress of a framework using existing symolic executions algorithm (current developed tool)
@article{LUCANU2017125,
title = "A generic framework for symbolic execution: A coinductive approach",
journal = "Journal of Symbolic Computation",
volume = "80",
pages = "125 - 163",
year = "2017",
note = "SI: Program Verification",
issn = "0747-7171",
doi = "https://doi.org/10.1016/j.jsc.2016.07.012",
url = "http://www.sciencedirect.com/science/article/pii/S0747717116300499",
pdfUrl = "https://ac.els-cdn.com/S0747717116300499/1-s2.0-S0747717116300499-main.pdf?_tid=087ddba8-6c4a-44cf-959e-2328f22c23d0&acdnat=1538387057_6f97f297433741ef2fc4ce19b4ec5203",
author = "Dorel Lucanu and Vlad Rusu and Andrei Arusoaie",
keywords = "Symbolic execution, Programming language, Formal operational semantics, Reachability logic, Circular coinduction, Program verification"
}

% Propose two optimization techniques to direct the successive runs of the symbolic execution technique
@incollection{KHALIL2018145,
title = "Chapter Four - Optimizing the Symbolic Execution of Evolving Rhapsody Statecharts",
editor = "Atif M. Memon",
series = "Advances in Computers",
publisher = "Elsevier",
volume = "108",
pages = "145 - 281",
year = "2018",
issn = "0065-2458",
doi = "https://doi.org/10.1016/bs.adcom.2017.09.003",
url = "http://www.sciencedirect.com/science/article/pii/S0065245817300487",
author = "Amal Khalil and Juergen Dingel",
keywords = "Model-driven engineering, Symbolic execution, Incremental verification, State-based behavioral models, State machines, Memoization, Dependency analysis, Model-based analysis",
abstract = "Model-driven engineering (MDE) is an iterative and incremental software development process. Supporting the analysis and the verification of software systems developed following the MDE paradigm requires to adopt incrementality when carrying out these crucial tasks in a more optimized way. Communicating state machines are one of the various formalisms used in MDE tools to model and describe the behavior of distributed, concurrent, and real-time reactive systems (e.g., automotive and avionics systems). Modeling the overall behavior of such systems is carried out in a modular way and on different levels of abstraction (i.e., it starts with modeling the behavior of the individual objects in the system first then modeling the interaction between these objects). Similarly, analyzing and verifying the correctness of the developed models to ensure their quality and their integrity is performed on two main levels. The intralevel is used to analyze the correctness of the individual models in isolation of the others, while the interlevel is used to analyze the overall interoperability of those that are communicating with each other. One way to facilitate the analysis of the overall behavior of a system of communicating state machines is to build the global state space (also known as the global reachability tree) of the system. This process is very expensive and in some cases it may suffer from the state explosion problem. Symbolic execution is a technique that can be used to construct an abstract and a bounded version of the system global state space that is known as a symbolic execution tree (SET), yet the size of the generated trees can be very large especially with big and complex systems that are composed of multiple objects. As the system evolves, one way to avoid regenerating the entire SET and repeating any SET-based analyses that have been already conducted is to utilize the previous SET and its analysis results in optimizing the process of generating the SET of the system after the change. In this chapter, we propose two optimization techniques to direct the successive runs of the symbolic execution technique toward the impacted parts of an evolving state machine model using memoization (MSE) and dependency analysis (DSE), respectively. The evaluation results of both techniques showed significant reduction in some cases compared with the standard symbolic execution technique."
}

% Special case of dynamic symbolic execution technique
% But I'm not sure if it can be consider a Symbolic execution techniques or if it just enhanced it
@article{CHEN2018118,
title = "A systematic review of fuzzing techniques",
journal = "Computers and Security",
volume = "75",
pages = "118 - 137",
year = "2018",
issn = "0167-4048",
doi = "https://doi.org/10.1016/j.cose.2018.02.002",
url = "http://www.sciencedirect.com/science/article/pii/S0167404818300658",
pdfUrl = "https://ac.els-cdn.com/S0167404818300658/1-s2.0-S0167404818300658-main.pdf?_tid=2882780d-dae9-4518-bde4-2aeb128d2b4f&acdnat=1538392161_75be7588cae51a09c2f11e86d9872fc8",
author = "Chen Chen and Baojiang Cui and Jinxin Ma and Runpu Wu and Jianchao Guo and Wenqian Liu",
keywords = "Software bug, Vulnerability, Fuzzing, Dynamic symbolic execution, Coverage guide, Grammar representation, Scheduling algorithms, Taint analysis, Static analysis",
abstract = "Fuzzing is an effective and widely used technique for finding security bugs and vulnerabilities in software. It inputs irregular test data into a target program to try to trigger a vulnerable condition in the program execution. Since the first random fuzzing system was constructed, fuzzing efficiency has been greatly improved by combination with several useful techniques, including dynamic symbolic execution, coverage guide, grammar representation, scheduling algorithms, dynamic taint analysis, static analysis and machine learning. In this paper, we will systematically review these techniques and their corresponding representative fuzzing systems. By introducing the principles, advantages and disadvantages of these techniques, we hope to provide researchers with a systematic and deeper understanding of fuzzing techniques and provide some references for this field."
}

% Little bit old, but looks lik a good base for "forward symbolic execution"
@INPROCEEDINGS{forwardSymbolicExecution,
author={E. J. Schwartz and T. Avgerinos and D. Brumley},
booktitle={2010 IEEE Symposium on Security and Privacy},
title={All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)},
year={2010},
volume={},
number={},
pages={317-331},
pdfUrl = "https://users.ece.cmu.edu/~aavgerin/papers/Oakland10.pdf",
abstract={Dynamic taint analysis and forward symbolic execution are quickly becoming staple techniques in security analyses. Example applications of dynamic taint analysis and forward symbolic execution include malware analysis, input filter generation, test case generation, and vulnerability discovery. Despite the widespread usage of these two techniques, there has been little effort to formally define the algorithms and summarize the critical issues that arise when these techniques are used in typical security contexts. The contributions of this paper are two-fold. First, we precisely describe the algorithms for dynamic taint analysis and forward symbolic execution as extensions to the run-time semantics of a general language. Second, we highlight important implementation choices, common pitfalls, and considerations when using these techniques in a security context.},
keywords={data analysis;security of data;dynamic taint analysis;forward symbolic execution;security analysis;malware analysis;input filter generation;test case generation;vulnerability discovery;security context;Filters;Runtime;Information analysis;Testing;Computerized monitoring;Performance analysis;Information security;Reactive power;Privacy;Heuristic algorithms;taint analysis;symbolic execution;dynamic analysis},
doi={10.1109/SP.2010.26},
ISSN={2375-1207},
month={May}
}

% TRACER tool presentation
@InProceedings{InfeasiblePathsEliminationWithSymbolicExecTechniques,
author="Aissat, Romain
and Voisin, Frédéric
and Wolff, Burkhart",
editor="Blanchette, Jasmin Christian
and Merz, Stephan",
title="Infeasible Paths Elimination by Symbolic Execution Techniques",
booktitle="Interactive Theorem Proving",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="36--51",
urlPdf="https://link.springer.com/content/pdf/10.1007%2F978-3-319-43144-4.pdf",
abstract="TRACER [8] is a tool for verifying safety properties of sequential C programs. TRACER attempts at building a finite symbolic execution graph which over-approximates the set of all concrete reachable states and the set of feasible paths.",
isbn="978-3-319-43144-4"
}

% Maybe a bit old, but looks promising; using the "Undefined Behaviors" technique
@inproceedings{Sharma:2014:EUB:2591062.2594450,
 author = {Sharma, Asankhaya},
 title = {Exploiting Undefined Behaviors for Efficient Symbolic Execution},
 booktitle = {Companion Proceedings of the 36th International Conference on Software Engineering},
 series = {ICSE Companion 2014},
 year = {2014},
 isbn = {978-1-4503-2768-8},
 location = {Hyderabad, India},
 pages = {727--729},
 numpages = {3},
 url = {http://doi.acm.org/10.1145/2591062.2594450},
 pdfUrl = "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.708.1773&rep=rep1&type=pdf",
 doi = {10.1145/2591062.2594450},
 acmid = {2594450},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Symbolic execution, compiler optimizations, undefined behaviors},
}

% Use of symbolic execution to detect a special case of bug (Buffer overflow)
@Article{Dudina2017,
author="Dudina, I. A.
and Belevantsev, A. A.",
title="Using static symbolic execution to detect buffer overflows",
journal="Programming and Computer Software",
year="2017",
month="Sep",
day="01",
volume="43",
number="5",
pages="277--288",
pdfUrl="https://link.springer.com/content/pdf/10.1134%2FS0361768817050024.pdf",
abstract="Buffer overrun remains one of the main sources of errors and vulnerabilities in the C/C++ source code. To detect such kind of defects, static analysis is widely used. In this paper, we propose a path-sensitive static analysis based on symbolic execution with state merging. For buffers with compile-time-known sizes, we present an interprocedural path- and context-sensitive overrun detection algorithm that finds program points satisfying a proposed error definition. The described approach was implemented in the Svace static analyzer without significant loss of performance. On Android 5.0.2, these detectors generated 351 warnings, 64{\%} of which were true positives. In addition, we describe a prototype of an intraprocedural heap buffer overflow detector and present an example of a defect found by this detector.",
issn="1608-3261",
doi="10.1134/S0361768817050024",
url="https://doi.org/10.1134/S0361768817050024"
}

% Interesting framework
@article{ArusoaieAndrei2015Sebo,
issn = {1477-8424},
abstract = {We propose a language-independent symbolic execution framework for languages endowed with a formal operational semantics based on term rewriting. Starting from a given definition of a language, a new language definition is generated, with the same syntax as the original one, but whose semantical rules are transformed in order to rewrite over logical formulas denoting possibly infinite sets of program states. Then, the symbolic execution of concrete programs is, by definition, the execution of the same programs with the symbolic semantics. We prove that the symbolic execution thus defined has the properties naturally expected from it (with respect to concrete program execution). A prototype implementation of our approach was developed in the K framework. We demonstrate the tool׳s genericity by instantiating it on several languages, and illustrate it on the reachability analysis and model checking of several programs. Highlights•We propose a language-independent symbolic execution framework for languages.•The proposed language-independent approach is based on language transformations.•We prove that the expected formal properties of symbolic execution.•We present a prototype and we use it on several languages.},
journal = {Computer Languages, Systems and Structures},
pages = {48--71},
volume = {44},
publisher = {Elsevier Ltd},
number = {PA},
year = {2015},
title = {Symbolic execution based on language transformation},
language = {eng},
author = {Arusoaie, Andrei and Lucanu, Dorel and Rusu, Vlad},
keywords = {Symbolic Execution ; Formal Semantics ; Programming Languages ; Program Analysis},
}

% Unit testing engine using concolic
@inproceedings{sen2006cute,
  title={CUTE and jCUTE: Concolic unit testing and explicit path model-checking tools},
  pdfLink="https://link.springer.com/content/pdf/10.1007%2F11817963_38.pdf",
  author={Sen, Koushik and Agha, Gul},
  booktitle={International Conference on Computer Aided Verification},
  pages={419--423},
  year={2006},
  organization={Springer}
}

% DART (avec Patrice Godefroid)
@inproceedings{godefroid2005dart,
  title={DART: directed automated random testing},
  author={Godefroid, Patrice and Klarlund, Nils and Sen, Koushik},
  booktitle={ACM Sigplan Notices},
  pdfUrl="https://web.eecs.umich.edu/~weimerw/2011-6610/reading/p213-godefroid.pdf",
  volume={40},
  number={6},
  pages={213--223},
  year={2005},
  organization={ACM}
}

@inproceedings{Godefroid2008AutomatedWF,
  title={Automated Whitebox Fuzz Testing},
  author={Patrice Godefroid and Michael Y. Levin and David A. Molnar},
  booktitle={NDSS},
  pdfUrl="https://patricegodefroid.github.io/public_psfiles/ndss2008.pdf",
  year={2008}
}

% interesting selective symolic execution
@article{chipounov2012s2e,
  title={The S2E platform: Design, implementation, and applications},
  author={Chipounov, Vitaly and Kuznetsov, Volodymyr and Candea, George},
  journal={ACM Transactions on Computer Systems (TOCS)},
  volume={30},
  number={1},
  pdfUrl="https://dslab.epfl.ch/pubs/s2e-tocs.pdf",
  pages={2},
  year={2012},
  publisher={ACM}
}

% site web de S²E
@online{S2EWebSite,
  howpublished={\href{https://s2e.systems/}{S2E Systems website, October 2018, https://s2e.systems}},
	url={https://s2e.systems/}

}

@online{CuteWebSite,
	howpublished={\href{http://osl.cs.illinois.edu/software/index.html}{Open Systems Laboratory, October 2018, http://osl.cs.illinois.edu/software/index.html}},
	url={http://osl.cs.illinois.edu/software/index.html}
}

@online{KleeGitRepo,
	howpublished={\href{https://github.com/klee/klee}{Klee Official Git Repository, https://github.com/klee/klee}},
	url={https://github.com/klee/klee}
}

@InProceedings{jDart,
	author="Luckow, Kasper
	and Dimja{\v{s}}evi{\'{c}}, Marko
	and Giannakopoulou, Dimitra
	and Howar, Falk
	and Isberner, Malte
	and Kahsai, Temesghen
	and Rakamari{\'{c}}, Zvonimir
	and Raman, Vishwanath",
	editor="Chechik, Marsha
	and Raskin, Jean-Fran{\c{c}}ois",
	title="JDart: A Dynamic Symbolic Analysis Framework",
	booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
	year="2016",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="442--459",
	pdfUrl="https://pdfs.semanticscholar.org/7d50/0d68e48c87c20925f5bc10fc5d861289a1a0.pdf",
	abstract="We describe JDart, a dynamic symbolic analysis framework for Java. A distinguishing feature of JDart is its modular architecture: the main component that performs dynamic exploration communicates with a component that efficiently constructs constraints and that interfaces with constraint solvers. These components can easily be extended or modified to support multiple constraint solvers or different exploration strategies. Moreover, JDart has been engineered for robustness, driven by the need to handle complex NASA software. These characteristics, together with its recent open sourcing, make JDart an ideal platform for research and experimentation. In the current release, JDart supports the CORAL, SMTInterpol, and Z3 solvers, and is able to handle NASA software with constraints containing bit operations, floating point arithmetic, and complex arithmetic operations (e.g., trigonometric and nonlinear). We illustrate how JDart has been used to support other analysis techniques, such as automated interface generation and testing of libraries. Finally, we demonstrate the versatility and effectiveness of JDart, and compare it with state-of-the-art dynamic or pure symbolic execution engines through an extensive experimental evaluation.",
	isbn="978-3-662-49674-9"
}
